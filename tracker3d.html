<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conductor Worktree Tracker 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas {
            display: block;
        }

        #header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        #header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
        }

        #header .subtitle {
            font-size: 12px;
            color: #888;
        }

        #status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            min-width: 180px;
        }

        #status-panel h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .status-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-working { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
        .status-idle { background: #666; }
        .status-error { background: #ef4444; }

        /* Color Legend Panel */
        #legend-panel {
            position: absolute;
            bottom: 120px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            min-width: 200px;
        }

        #legend-panel h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .legend-section {
            margin-bottom: 12px;
        }

        .legend-section:last-child {
            margin-bottom: 0;
        }

        .legend-section h4 {
            font-size: 11px;
            color: #666;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .legend-gradient {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            background: linear-gradient(to right, #22c55e, #eab308, #f97316, #ef4444);
            margin-bottom: 4px;
        }

        .legend-gradient-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #888;
        }

        .ci-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .ci-pass { background: #22c55e; color: white; }
        .ci-fail { background: #ef4444; color: white; }
        .ci-pending { background: #eab308; color: white; }

        .pr-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
        }

        .pr-pass { background: rgba(34, 197, 94, 0.9); }
        .pr-fail { background: rgba(239, 68, 68, 0.9); }
        .pr-pending { background: rgba(234, 179, 8, 0.9); }
        .pr-none { background: rgba(80, 80, 220, 0.9); }

        .time-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            background: rgba(0, 0, 0, 0.7);
            flex-shrink: 0;
        }

        .time-fresh { color: #88ff88; }
        .time-aging { color: #ffcc44; }
        .time-stale { color: #ff6666; }

        body.light-mode #legend-panel {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.light-mode #legend-panel h3 {
            color: #666;
            border-bottom-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode .legend-section h4 {
            color: #888;
        }

        body.light-mode .legend-item {
            color: #333;
        }

        body.light-mode .legend-gradient-labels {
            color: #666;
        }

        body.light-mode .time-badge {
            background: rgba(0, 0, 0, 0.15);
        }

        body.light-mode .time-fresh { color: #16a34a; }
        body.light-mode .time-aging { color: #ca8a04; }
        body.light-mode .time-stale { color: #dc2626; }

        #footer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 12px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #footer .tracking-info {
            font-size: 13px;
            color: #aaa;
        }

        #footer .session-time {
            font-size: 13px;
            color: #888;
        }

        #tooltip {
            position: absolute;
            background: rgba(20, 20, 30, 0.95);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: none;
            display: none;
            z-index: 1000;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }

        #tooltip .tooltip-title {
            font-weight: 600;
            font-size: 14px;
            color: #fff;
            margin-bottom: 6px;
        }

        #tooltip .tooltip-repo {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
        }

        #tooltip .tooltip-time {
            font-size: 12px;
            color: #aaa;
        }

        #tooltip .tooltip-status {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
            font-size: 12px;
        }

        #hide-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(15, 15, 25, 0.95);
            padding: 25px 30px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            display: none;
            min-width: 400px;
            max-height: 70vh;
            overflow-y: auto;
        }

        #hide-menu h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #fff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        #hide-menu .menu-section {
            margin-bottom: 20px;
        }

        #hide-menu .menu-section h4 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 10px;
        }

        #hide-menu .menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #hide-menu .menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        #hide-menu .menu-item.hidden {
            opacity: 0.5;
        }

        #hide-menu .menu-item .key {
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            margin-right: 10px;
        }

        #hide-menu .menu-item .name {
            flex: 1;
            font-size: 13px;
        }

        #hide-menu .menu-item .status-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
        }

        #hide-menu .menu-item .status-badge.visible {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        #hide-menu .menu-item .status-badge.hidden {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }

        #hide-menu .close-hint {
            text-align: center;
            font-size: 12px;
            color: #666;
            margin-top: 15px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #22c55e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .controls-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        /* Theme toggle button */
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 220px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: #e0e0e0;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: rgba(30, 30, 40, 0.9);
        }

        .theme-toggle .icon {
            font-size: 16px;
        }

        /* Fit to screen button */
        .fit-button {
            position: absolute;
            top: 20px;
            right: 305px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: #e0e0e0;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .fit-button:hover {
            background: rgba(30, 30, 40, 0.9);
        }

        .fit-button.active {
            background: rgba(34, 197, 94, 0.3);
            border-color: rgba(34, 197, 94, 0.5);
        }

        .fit-button .icon {
            font-size: 14px;
        }

        body.light-mode .fit-button {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #333;
        }

        body.light-mode .fit-button:hover {
            background: rgba(240, 240, 245, 0.95);
        }

        body.light-mode .fit-button.active {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.4);
        }

        /* Lock button */
        .lock-button {
            position: absolute;
            top: 20px;
            right: 380px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: #e0e0e0;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .lock-button:hover {
            background: rgba(30, 30, 40, 0.9);
        }

        .lock-button.active {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
        }

        .lock-button .icon {
            font-size: 14px;
        }

        body.light-mode .lock-button {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #333;
        }

        body.light-mode .lock-button:hover {
            background: rgba(240, 240, 245, 0.95);
        }

        body.light-mode .lock-button.active {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
        }

        /* CI Refresh button */
        .ci-button {
            position: absolute;
            top: 20px;
            right: 455px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: #e0e0e0;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .ci-button:hover {
            background: rgba(30, 30, 40, 0.9);
        }

        .ci-button.loading {
            opacity: 0.7;
            cursor: wait;
        }

        .ci-button .icon {
            font-size: 14px;
            transition: transform 0.3s ease;
        }

        .ci-button.loading .icon {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        body.light-mode .ci-button {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #333;
        }

        body.light-mode .ci-button:hover {
            background: rgba(240, 240, 245, 0.95);
        }

        /* Colorblind mode button */
        .colorblind-button {
            position: absolute;
            top: 20px;
            right: 510px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: #e0e0e0;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .colorblind-button:hover {
            background: rgba(30, 30, 40, 0.9);
        }

        .colorblind-button.active {
            background: rgba(100, 149, 237, 0.3);
            border-color: rgba(100, 149, 237, 0.5);
        }

        .colorblind-button .icon {
            font-size: 14px;
        }

        body.light-mode .colorblind-button {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #333;
        }

        body.light-mode .colorblind-button:hover {
            background: rgba(240, 240, 245, 0.95);
        }

        body.light-mode .colorblind-button.active {
            background: rgba(100, 149, 237, 0.2);
            border-color: rgba(100, 149, 237, 0.4);
        }

        /* Emoji legend for colorblind mode */
        #emoji-legend {
            display: none;
        }

        body.colorblind-mode #emoji-legend {
            display: block;
        }

        body.colorblind-mode #legend-panel {
            display: none;
        }

        #emoji-legend {
            position: absolute;
            bottom: 120px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            min-width: 200px;
        }

        #emoji-legend h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .emoji-legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .emoji-legend-item .emoji {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }

        body.light-mode #emoji-legend {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.light-mode #emoji-legend h3 {
            color: #666;
            border-bottom-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode .emoji-legend-item {
            color: #333;
        }

        /* Spacing slider control */
        .spacing-control {
            position: absolute;
            bottom: 80px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 16px;
            backdrop-filter: blur(10px);
            min-width: 180px;
        }

        .spacing-control label {
            display: block;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 8px;
        }

        .spacing-control input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .spacing-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            border: 2px solid #fff;
        }

        .spacing-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            border: 2px solid #fff;
        }

        .spacing-value {
            font-size: 12px;
            color: #e0e0e0;
            text-align: right;
            margin-top: 4px;
        }

        body.light-mode .spacing-control {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.light-mode .spacing-control label {
            color: #666;
        }

        body.light-mode .spacing-control input[type="range"] {
            background: rgba(0, 0, 0, 0.1);
        }

        body.light-mode .spacing-value {
            color: #333;
        }

        /* Light mode styles */
        body.light-mode {
            background: #f5f5f7;
            color: #1a1a1a;
        }

        body.light-mode #header {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.light-mode #header h1 {
            color: #1a1a1a;
        }

        body.light-mode #header .subtitle {
            color: #666;
        }

        body.light-mode #status-panel {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.light-mode #status-panel h3 {
            color: #666;
            border-bottom-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode .status-item {
            color: #333;
        }

        body.light-mode #footer {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.light-mode #footer .tracking-info {
            color: #555;
        }

        body.light-mode #footer .session-time {
            color: #777;
        }

        body.light-mode #tooltip {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.15);
        }

        body.light-mode #tooltip .tooltip-title {
            color: #1a1a1a;
        }

        body.light-mode #tooltip .tooltip-repo {
            color: #666;
        }

        body.light-mode #tooltip .tooltip-time {
            color: #555;
        }

        body.light-mode #hide-menu {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.15);
        }

        body.light-mode #hide-menu h2 {
            color: #1a1a1a;
            border-bottom-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode #hide-menu .menu-section h4 {
            color: #666;
        }

        body.light-mode #hide-menu .menu-item:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        body.light-mode #hide-menu .menu-item .key {
            background: rgba(0, 0, 0, 0.08);
            color: #333;
        }

        body.light-mode #hide-menu .menu-item .name {
            color: #333;
        }

        body.light-mode .controls-hint {
            color: #888;
        }

        body.light-mode .theme-toggle {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #333;
        }

        body.light-mode .theme-toggle:hover {
            background: rgba(240, 240, 245, 0.95);
        }

        body.light-mode .loading {
            color: #333;
        }

        body.light-mode .loading-spinner {
            border-color: rgba(0, 0, 0, 0.1);
            border-top-color: #22c55e;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <div id="header">
            <h1>CONDUCTOR WORKTREE TRACKER</h1>
            <div class="subtitle">3D Visualization</div>
        </div>

        <button class="colorblind-button" id="colorblind-button" onclick="toggleColorblind()">
            <span class="icon" id="colorblind-icon">üëÅ</span>
            <span id="colorblind-label">A11y</span>
        </button>

        <button class="ci-button" id="ci-button" onclick="refreshCI()">
            <span class="icon" id="ci-icon">‚Üª</span>
            <span id="ci-label">CI</span>
        </button>

        <button class="lock-button" id="lock-button" onclick="toggleLock()">
            <span class="icon" id="lock-icon">üîì</span>
            <span id="lock-label">Lock</span>
        </button>

        <button class="fit-button" id="fit-button" onclick="toggleAutoFit()">
            <span class="icon">‚ä°</span>
            <span id="fit-label">Fit</span>
        </button>

        <button class="theme-toggle" id="theme-toggle" onclick="toggleTheme()">
            <span class="icon" id="theme-icon">&#9790;</span>
            <span id="theme-label">Light</span>
        </button>

        <div id="status-panel">
            <h3>Status</h3>
            <div id="status-counts">
                <div class="status-item">
                    <div class="status-icon status-working"></div>
                    <span><span id="working-count">0</span> working</span>
                </div>
                <div class="status-item">
                    <div class="status-icon status-idle"></div>
                    <span><span id="idle-count">0</span> idle</span>
                </div>
                <div class="status-item">
                    <div class="status-icon status-error"></div>
                    <span><span id="error-count">0</span> error</span>
                </div>
            </div>
        </div>

        <div id="legend-panel">
            <h3>Legend</h3>
            <div class="legend-section">
                <h4>Worktree Freshness</h4>
                <div class="legend-gradient"></div>
                <div class="legend-gradient-labels">
                    <span>Fresh</span>
                    <span>Stale</span>
                </div>
            </div>
            <div class="legend-section">
                <h4>PR Label (above ball)</h4>
                <div class="legend-item">
                    <div class="pr-badge pr-pass">#123 ‚úì</div>
                    <span>CI Passing</span>
                </div>
                <div class="legend-item">
                    <div class="pr-badge pr-fail">#123 ‚úó</div>
                    <span>CI Failing</span>
                </div>
                <div class="legend-item">
                    <div class="pr-badge pr-pending">#123 ‚ãØ</div>
                    <span>CI Pending</span>
                </div>
                <div class="legend-item">
                    <div class="pr-badge pr-none">#123 ‚óå</div>
                    <span>CI Loading/Unknown</span>
                </div>
            </div>
            <div class="legend-section">
                <h4>Time Indicator</h4>
                <div class="legend-item">
                    <div class="time-badge time-fresh">5m</div>
                    <span>Recently active</span>
                </div>
                <div class="legend-item">
                    <div class="time-badge time-aging">2h</div>
                    <span>Getting stale</span>
                </div>
                <div class="legend-item">
                    <div class="time-badge time-stale">1d</div>
                    <span>Stale</span>
                </div>
            </div>
            <div class="legend-section">
                <h4>Session Status</h4>
                <div class="legend-item">
                    <div class="status-icon status-working"></div>
                    <span>Working (model shown)</span>
                </div>
                <div class="legend-item">
                    <span style="font-size: 16px;">‚è≥</span>
                    <span>Awaiting input</span>
                </div>
            </div>
        </div>

        <div id="emoji-legend">
            <h3>Legend (Colorblind Mode)</h3>
            <div class="legend-section">
                <h4>Worktree Freshness</h4>
                <div class="emoji-legend-item">
                    <span class="emoji">‚ú®</span>
                    <span>Fresh (active recently)</span>
                </div>
                <div class="emoji-legend-item">
                    <span class="emoji">‚ö°</span>
                    <span>Recent activity</span>
                </div>
                <div class="emoji-legend-item">
                    <span class="emoji">‚è∞</span>
                    <span>Getting stale</span>
                </div>
                <div class="emoji-legend-item">
                    <span class="emoji">üí§</span>
                    <span>Stale (inactive)</span>
                </div>
            </div>
            <div class="legend-section">
                <h4>CI Status</h4>
                <div class="emoji-legend-item">
                    <span class="emoji">‚úì</span>
                    <span>CI Passing</span>
                </div>
                <div class="emoji-legend-item">
                    <span class="emoji">‚úó</span>
                    <span>CI Failing</span>
                </div>
                <div class="emoji-legend-item">
                    <span class="emoji">‚ãØ</span>
                    <span>CI Pending</span>
                </div>
                <div class="emoji-legend-item">
                    <span class="emoji">‚óå</span>
                    <span>CI Unknown</span>
                </div>
            </div>
            <div class="legend-section">
                <h4>Session Status</h4>
                <div class="emoji-legend-item">
                    <span class="emoji">‚öôÔ∏è</span>
                    <span>Working (model shown)</span>
                </div>
                <div class="emoji-legend-item">
                    <span class="emoji">‚è≥</span>
                    <span>Awaiting input</span>
                </div>
            </div>
        </div>

        <div class="spacing-control">
            <label>Repo Spacing</label>
            <input type="range" id="spacing-slider" min="0.5" max="15" step="0.25" value="6" oninput="updateRepoSpacing(this.value)">
            <div class="spacing-value"><span id="spacing-value">6</span></div>
        </div>

        <div id="footer">
            <div class="tracking-info">
                Tracking: <span id="worktree-count">0</span> worktrees |
                <span id="hidden-info"></span>
            </div>
            <div class="session-time">
                Session: <span id="session-duration">0m</span> |
                Press <kbd>`</kbd> to hide/show
            </div>
        </div>

        <div id="tooltip">
            <div class="tooltip-title"></div>
            <div class="tooltip-repo"></div>
            <div class="tooltip-time"></div>
            <div class="tooltip-status"></div>
        </div>

        <div id="hide-menu">
            <h2>Hide/Show Workspaces & Repos</h2>
            <div id="repos-section" class="menu-section">
                <h4>Repositories</h4>
                <div id="repos-list"></div>
            </div>
            <div id="workspaces-section" class="menu-section">
                <h4>Workspaces</h4>
                <div id="workspaces-list"></div>
            </div>
            <div class="close-hint">Press <kbd>`</kbd> or <kbd>Esc</kbd> to close | <kbd>0</kbd> show all</div>
        </div>

        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div>Connecting to Conductor...</div>
        </div>

        <div class="controls-hint">
            Drag to rotate | Shift+drag to pan | Scroll to zoom | Hover for details | Click to open | T theme | F fit | L lock | C a11y
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    // ============================================================================
    // Configuration
    // ============================================================================
    const CONFIG = {
        apiUrl: 'http://localhost:8765/api/tracker',
        pollInterval: 2000,
        staleMinutes: 30,
        colors: {
            fresh: 0x22c55e,      // green
            recent: 0xeab308,      // yellow
            aging: 0xf97316,       // orange
            stale: 0xef4444,       // red
            working: 0x22c55e,
            idle: 0x666666,
            error: 0xef4444,
            pending: 0xeab308,
            pass: 0x22c55e,
            fail: 0xef4444,
        },
        scene: {
            dark: {
                background: 0x0a0a0f,
                ambientLight: 0x404040,
                directionalLight: 0xffffff,
                gridColor: 0x222233,
                lineColor: 0x444466,
                commitColor: 0x88aaff,
            },
            light: {
                background: 0xf0f0f5,
                ambientLight: 0x808080,
                directionalLight: 0xffffff,
                gridColor: 0xccccdd,
                lineColor: 0x8888aa,
                commitColor: 0x5577dd,
            },
        }
    };

    // Theme state
    let isDarkMode = true;

    function toggleTheme() {
        isDarkMode = !isDarkMode;
        document.body.classList.toggle('light-mode', !isDarkMode);

        // Update button text and icon
        const themeIcon = document.getElementById('theme-icon');
        const themeLabel = document.getElementById('theme-label');
        themeIcon.innerHTML = isDarkMode ? '&#9790;' : '&#9788;';  // Moon or Sun
        themeLabel.textContent = isDarkMode ? 'Light' : 'Dark';

        // Update Three.js scene colors
        if (scene) {
            const themeColors = getThemeColors();

            // Update background and fog
            scene.background = new THREE.Color(themeColors.background);
            scene.fog.color = new THREE.Color(themeColors.background);

            // Update ambient light
            const ambientLight = scene.getObjectByName('ambientLight');
            if (ambientLight) {
                ambientLight.color = new THREE.Color(themeColors.ambientLight);
            }

            // Update grid
            const oldGrid = scene.getObjectByName('gridHelper');
            if (oldGrid) {
                scene.remove(oldGrid);
                oldGrid.geometry.dispose();
                oldGrid.material.dispose();

                const gridColor = isDarkMode ? 0x222233 : 0xccccdd;
                const gridColorSecondary = isDarkMode ? 0x111122 : 0xddddee;
                const newGrid = new THREE.GridHelper(30, 30, gridColor, gridColorSecondary);
                newGrid.name = 'gridHelper';
                newGrid.position.y = -3;
                scene.add(newGrid);
            }

            // Rebuild scene to update all node colors
            clearScene();
            buildScene();
        }

        // Save preference
        localStorage.setItem('conductor-tracker-theme', isDarkMode ? 'dark' : 'light');
    }

    function loadSavedTheme() {
        const savedTheme = localStorage.getItem('conductor-tracker-theme');
        if (savedTheme === 'light') {
            isDarkMode = false;
            document.body.classList.add('light-mode');
            const themeIcon = document.getElementById('theme-icon');
            const themeLabel = document.getElementById('theme-label');
            themeIcon.innerHTML = '&#9788;';  // Sun
            themeLabel.textContent = 'Dark';
        }
    }

    // ============================================================================
    // State
    // ============================================================================
    let state = {
        trackerData: null,
        sessionStart: Date.now(),
        hiddenWorkspaces: new Set(),
        hiddenRepos: new Set(),
        hideMenuOpen: false,
        hoveredNode: null,
        nodes: new Map(),  // Map of workspace_id -> mesh
        lines: [],         // Connection lines
        repoGroups: new Map(), // Map of repo_name -> group
        useDemo: false,    // Whether using demo data
        previousStatuses: new Map(),  // Track previous session statuses for transition detection
        flashingNodes: new Map(),     // Map of workspace_id -> { startTime, mesh }
        autoFit: false,               // Whether to continuously fit content to screen
        fitZoom: 1.0,                 // Zoom multiplier for fit mode (smaller = closer)
        repoSpacing: 6,               // Radius of the circle for repo positioning
        locked: false,                // Whether scene updates are paused
        colorblind: false,            // Whether colorblind mode is enabled (emojis instead of colors)
    };

    // ============================================================================
    // Three.js Setup
    // ============================================================================
    let scene, camera, renderer, raycaster, mouse;
    let cameraAngle = 0;
    let cameraRadius = 15;
    let cameraHeight = 8;
    let cameraTargetX = 0;  // Pan target X
    let cameraTargetZ = 0;  // Pan target Z
    let isDragging = false;
    let isPanning = false;  // Shift+drag for panning
    let previousMousePosition = { x: 0, y: 0 };
    let spinnerRotation = 0;
    let dragStartTime = 0;  // Track drag duration for click detection

    function getThemeColors() {
        return isDarkMode ? CONFIG.scene.dark : CONFIG.scene.light;
    }

    // ============================================================================
    // Fit to Screen
    // ============================================================================
    function toggleAutoFit() {
        state.autoFit = !state.autoFit;
        const button = document.getElementById('fit-button');
        const label = document.getElementById('fit-label');

        if (state.autoFit) {
            button.classList.add('active');
            label.textContent = 'Auto';
            // Reset zoom to default and immediately fit to screen
            state.fitZoom = 1.0;
            fitToScreen();
        } else {
            button.classList.remove('active');
            label.textContent = 'Fit';
        }
    }

    function updateRepoSpacing(value) {
        state.repoSpacing = parseFloat(value);
        document.getElementById('spacing-value').textContent = value;
        // Rebuild the scene with new spacing
        rebuildScene();
    }

    function toggleLock() {
        state.locked = !state.locked;
        const button = document.getElementById('lock-button');
        const icon = document.getElementById('lock-icon');
        const label = document.getElementById('lock-label');

        if (state.locked) {
            button.classList.add('active');
            icon.textContent = 'üîí';
            label.textContent = 'Locked';
        } else {
            button.classList.remove('active');
            icon.textContent = 'üîì';
            label.textContent = 'Lock';
            // Rebuild scene with latest data when unlocking
            if (state.trackerData) {
                buildScene();
                updateStatusPanel();
                updateFooter();
            }
        }
    }

    async function refreshCI() {
        const button = document.getElementById('ci-button');
        const label = document.getElementById('ci-label');

        // Prevent multiple clicks
        if (button.classList.contains('loading')) return;

        button.classList.add('loading');
        label.textContent = '...';

        try {
            const response = await fetch(CONFIG.apiUrl + '?refresh_ci=true', {
                method: 'GET',
            });

            if (response.ok) {
                // Fetch fresh data after CI refresh
                await fetchData();
                label.textContent = '‚úì';
                setTimeout(() => {
                    label.textContent = 'CI';
                }, 1500);
            } else {
                throw new Error('Failed to refresh CI');
            }
        } catch (error) {
            console.error('CI refresh failed:', error);
            label.textContent = '‚úó';
            setTimeout(() => {
                label.textContent = 'CI';
            }, 1500);
        } finally {
            button.classList.remove('loading');
        }
    }

    function toggleColorblind() {
        state.colorblind = !state.colorblind;
        document.body.classList.toggle('colorblind-mode', state.colorblind);

        const button = document.getElementById('colorblind-button');
        const label = document.getElementById('colorblind-label');

        if (state.colorblind) {
            button.classList.add('active');
            label.textContent = 'On';
        } else {
            button.classList.remove('active');
            label.textContent = 'A11y';
        }

        // Rebuild scene to update ball colors and add/remove emoji indicators
        clearScene();
        buildScene();

        // Save preference
        localStorage.setItem('conductor-tracker-colorblind', state.colorblind ? 'true' : 'false');
    }

    function loadSavedColorblind() {
        const saved = localStorage.getItem('conductor-tracker-colorblind');
        if (saved === 'true') {
            state.colorblind = true;
            document.body.classList.add('colorblind-mode');
            const button = document.getElementById('colorblind-button');
            const label = document.getElementById('colorblind-label');
            button.classList.add('active');
            label.textContent = 'On';
        }
    }

    // Get emoji for freshness status score (0-1, where 0 is fresh, 1 is stale)
    function getFreshnessEmoji(statusScore) {
        if (statusScore < 0.25) return '‚ú®';  // Fresh
        if (statusScore < 0.5) return '‚ö°';   // Recent
        if (statusScore < 0.75) return '‚è∞';  // Aging
        return 'üí§';                          // Stale
    }

    // Get grayscale color for colorblind mode
    function getColorblindGray(statusScore) {
        // Lighter gray for fresh, darker for stale
        const brightness = Math.floor(200 - statusScore * 100);  // 200 (fresh) to 100 (stale)
        return (brightness << 16) | (brightness << 8) | brightness;
    }

    function fitToScreen() {
        // Calculate bounding box of all visible content
        const bounds = {
            minX: Infinity, maxX: -Infinity,
            minY: Infinity, maxY: -Infinity,
            minZ: Infinity, maxZ: -Infinity
        };

        let hasContent = false;

        // Include all workspace nodes
        state.nodes.forEach((mesh) => {
            const pos = new THREE.Vector3();
            mesh.getWorldPosition(pos);
            bounds.minX = Math.min(bounds.minX, pos.x);
            bounds.maxX = Math.max(bounds.maxX, pos.x);
            bounds.minY = Math.min(bounds.minY, pos.y);
            bounds.maxY = Math.max(bounds.maxY, pos.y);
            bounds.minZ = Math.min(bounds.minZ, pos.z);
            bounds.maxZ = Math.max(bounds.maxZ, pos.z);
            hasContent = true;
        });

        // Include repo center balls
        state.repoGroups.forEach((group) => {
            group.children.forEach((child) => {
                if (child.userData && child.userData.type === 'repo') {
                    const pos = new THREE.Vector3();
                    child.getWorldPosition(pos);
                    bounds.minX = Math.min(bounds.minX, pos.x);
                    bounds.maxX = Math.max(bounds.maxX, pos.x);
                    bounds.minY = Math.min(bounds.minY, pos.y);
                    bounds.maxY = Math.max(bounds.maxY, pos.y);
                    bounds.minZ = Math.min(bounds.minZ, pos.z);
                    bounds.maxZ = Math.max(bounds.maxZ, pos.z);
                    hasContent = true;
                }
            });
        });

        if (!hasContent) return;

        // Calculate center and size
        const centerX = (bounds.minX + bounds.maxX) / 2;
        const centerZ = (bounds.minZ + bounds.maxZ) / 2;
        const sizeX = bounds.maxX - bounds.minX;
        const sizeZ = bounds.maxZ - bounds.minZ;
        const maxSize = Math.max(sizeX, sizeZ, 4);  // Minimum size of 4

        // Calculate required camera height for bird's eye (aerial) view
        const fov = camera.fov * (Math.PI / 180);
        const aspect = camera.aspect;

        // For bird's eye view, height needed to see the full spread from above
        const padding = 2.0;  // Extra padding for labels below balls
        const heightForZ = (maxSize * padding) / (2 * Math.tan(fov / 2));  // For Z spread (vertical in view)
        const heightForX = (maxSize * padding) / (2 * Math.tan(fov / 2) * aspect);  // For X spread (horizontal)
        const baseHeight = Math.max(heightForZ, heightForX, 15);

        // Apply zoom multiplier (smaller fitZoom = closer to content)
        const targetHeight = baseHeight * state.fitZoom;

        // Smoothly interpolate camera position
        const lerpFactor = 0.08;  // Smooth transition

        // Move camera target to center of content
        cameraTargetX += (centerX - cameraTargetX) * lerpFactor;
        cameraTargetZ += (centerZ - cameraTargetZ) * lerpFactor;

        // For bird's eye view: set radius to near zero (camera directly above target)
        cameraRadius += (0.01 - cameraRadius) * lerpFactor;

        // Set camera height to see everything from above
        cameraHeight += (targetHeight - cameraHeight) * lerpFactor;

        // Clamp values
        cameraRadius = Math.max(0.01, Math.min(40, cameraRadius));
        cameraHeight = Math.max(5, Math.min(80, cameraHeight));

        updateCameraPosition();
    }

    function initThree() {
        const canvas = document.getElementById('canvas');
        const container = document.getElementById('container');
        const themeColors = getThemeColors();

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(themeColors.background);
        scene.fog = new THREE.Fog(themeColors.background, 20, 50);

        // Camera
        camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        updateCameraPosition();

        // Renderer
        renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: true,
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Lighting
        const ambientLight = new THREE.AmbientLight(themeColors.ambientLight, 0.6);
        ambientLight.name = 'ambientLight';
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(themeColors.directionalLight, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.name = 'directionalLight';
        scene.add(directionalLight);

        const directionalLight2 = new THREE.DirectionalLight(0x8888ff, 0.3);
        directionalLight2.position.set(-10, -10, -10);
        directionalLight2.name = 'directionalLight2';
        scene.add(directionalLight2);

        // Add subtle grid
        const gridColor = isDarkMode ? 0x222233 : 0xccccdd;
        const gridColorSecondary = isDarkMode ? 0x111122 : 0xddddee;
        const gridHelper = new THREE.GridHelper(30, 30, gridColor, gridColorSecondary);
        gridHelper.name = 'gridHelper';
        gridHelper.position.y = -3;
        scene.add(gridHelper);

        // Raycaster for mouse picking
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Event listeners
        window.addEventListener('resize', onWindowResize);
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('click', onClick);
        canvas.addEventListener('wheel', onWheel);
        document.addEventListener('keydown', onKeyDown);
    }

    function updateCameraPosition() {
        camera.position.x = cameraTargetX + Math.sin(cameraAngle) * cameraRadius;
        camera.position.z = cameraTargetZ + Math.cos(cameraAngle) * cameraRadius;
        camera.position.y = cameraHeight;
        camera.lookAt(cameraTargetX, 0, cameraTargetZ);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        if (isDragging) {
            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            if (isPanning || event.shiftKey) {
                // Shift+drag = pan
                isPanning = true;
                const panSpeed = 0.005 * cameraRadius;  // Reduced sensitivity
                // Pan perpendicular to camera direction
                cameraTargetX -= Math.cos(cameraAngle) * deltaMove.x * panSpeed;
                cameraTargetZ += Math.sin(cameraAngle) * deltaMove.x * panSpeed;
                cameraTargetX -= Math.sin(cameraAngle) * deltaMove.y * panSpeed;
                cameraTargetZ -= Math.cos(cameraAngle) * deltaMove.y * panSpeed;
            } else {
                // Regular drag = orbit
                cameraAngle -= deltaMove.x * 0.005;
                cameraHeight += deltaMove.y * 0.05;
                cameraHeight = Math.max(2, Math.min(20, cameraHeight));
            }

            updateCameraPosition();

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        // Update tooltip position
        const tooltip = document.getElementById('tooltip');
        tooltip.style.left = (event.clientX + 15) + 'px';
        tooltip.style.top = (event.clientY + 15) + 'px';
    }

    function onMouseDown(event) {
        isDragging = true;
        isPanning = event.shiftKey;
        dragStartTime = Date.now();
        previousMousePosition = {
            x: event.clientX,
            y: event.clientY
        };
    }

    function onMouseUp(event) {
        isDragging = false;
        isPanning = false;
    }

    function onClick(event) {
        // Don't handle clicks if we were dragging for more than 200ms
        const dragDuration = Date.now() - dragStartTime;
        if (dragDuration > 200) return;

        // Update mouse position
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Check commit nodes first
        if (state.commitNodes && state.commitNodes.length > 0) {
            const commitIntersects = raycaster.intersectObjects(state.commitNodes, false);
            if (commitIntersects.length > 0) {
                const commitMesh = commitIntersects[0].object;
                if (commitMesh.userData.type === 'commit' && commitMesh.userData.github_url) {
                    window.open(commitMesh.userData.github_url, '_blank');
                    return;
                }
            }
        }

        // Check workspace nodes - click to open PR on GitHub
        const workspaceIntersects = raycaster.intersectObjects(Array.from(state.nodes.values()), true);
        if (workspaceIntersects.length > 0) {
            let targetMesh = workspaceIntersects[0].object;
            // Walk up to find workspace mesh
            while (targetMesh && (!targetMesh.userData || targetMesh.userData.type !== 'workspace')) {
                targetMesh = targetMesh.parent;
            }
            if (targetMesh && targetMesh.userData.type === 'workspace') {
                const data = targetMesh.userData.data;
                if (data.pr_number && data.github_url) {
                    // Open PR page
                    window.open(`${data.github_url}/pull/${data.pr_number}`, '_blank');
                    return;
                } else if (data.github_url && data.branch) {
                    // Open branch page
                    window.open(`${data.github_url}/tree/${data.branch}`, '_blank');
                    return;
                }
            }
        }

        // Check repo balls
        const repoBalls = [];
        state.repoGroups.forEach(group => {
            group.children.forEach(child => {
                if (child.userData && child.userData.type === 'repo') {
                    repoBalls.push(child);
                }
            });
        });

        if (repoBalls.length > 0) {
            const repoIntersects = raycaster.intersectObjects(repoBalls, false);
            if (repoIntersects.length > 0) {
                const repoBall = repoIntersects[0].object;
                if (repoBall.userData.github_url) {
                    window.open(repoBall.userData.github_url, '_blank');
                    return;
                }
            }
        }
    }

    function onWheel(event) {
        if (state.autoFit) {
            // In fit mode, adjust zoom multiplier (smaller = closer)
            state.fitZoom += event.deltaY * 0.002;
            state.fitZoom = Math.max(0.3, Math.min(3.0, state.fitZoom));
        } else {
            cameraRadius += event.deltaY * 0.01;
            cameraRadius = Math.max(5, Math.min(30, cameraRadius));
            updateCameraPosition();
        }
    }

    function onKeyDown(event) {
        if (event.key === '`' || event.key === 'Escape') {
            if (state.hideMenuOpen) {
                closeHideMenu();
            } else if (event.key === '`') {
                openHideMenu();
            }
        } else if (event.key === 't' || event.key === 'T') {
            // Toggle theme with 't' key
            toggleTheme();
        } else if (event.key === 'f' || event.key === 'F') {
            // Toggle auto-fit with 'f' key
            toggleAutoFit();
        } else if (event.key === 'l' || event.key === 'L') {
            // Toggle lock with 'l' key
            toggleLock();
        } else if (event.key === 'c' || event.key === 'C') {
            // Toggle colorblind mode with 'c' key
            toggleColorblind();
        } else if (event.key === '0' && state.hideMenuOpen) {
            state.hiddenWorkspaces.clear();
            state.hiddenRepos.clear();
            updateHideMenu();
            rebuildScene();
        } else if (state.hideMenuOpen) {
            handleHideMenuKey(event.key);
        }
    }

    // ============================================================================
    // Scene Building
    // ============================================================================
    function clearScene() {
        // Remove all workspace nodes
        state.nodes.forEach((mesh) => {
            scene.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
        });
        state.nodes.clear();

        // Remove connection lines
        state.lines.forEach((line) => {
            scene.remove(line);
            if (line.geometry) line.geometry.dispose();
            if (line.material) line.material.dispose();
        });
        state.lines = [];

        // Clear commit nodes
        if (state.commitNodes) {
            state.commitNodes = [];
        }

        // Remove repo groups (this also removes commit points as they're children)
        state.repoGroups.forEach((group) => {
            // Recursively dispose of all children
            group.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
            scene.remove(group);
        });
        state.repoGroups.clear();
    }

    function buildScene() {
        if (!state.trackerData) return;

        clearScene();

        const { trees } = state.trackerData;
        if (!trees || Object.keys(trees).length === 0) return;

        const repoNames = Object.keys(trees).filter(name => !state.hiddenRepos.has(name));
        const numRepos = repoNames.length;

        repoNames.forEach((repoName, repoIndex) => {
            const tree = trees[repoName];

            // Calculate position based on number of visible repos
            let repoX, repoZ, angle;
            if (numRepos === 1) {
                // Single repo - center it
                repoX = 0;
                repoZ = 0;
                angle = 0;
            } else if (numRepos === 2) {
                // Two repos - opposite each other
                angle = repoIndex * Math.PI;  // 0 or PI (180 degrees)
                repoX = Math.cos(angle) * state.repoSpacing;
                repoZ = Math.sin(angle) * state.repoSpacing;
            } else {
                // 3+ repos - evenly distributed around the circle
                angle = (repoIndex / numRepos) * Math.PI * 2 - Math.PI / 2;
                repoX = Math.cos(angle) * state.repoSpacing;
                repoZ = Math.sin(angle) * state.repoSpacing;
            }

            // Create repo group
            const repoGroup = new THREE.Group();
            repoGroup.userData = { type: 'repo', name: repoName, github_url: tree.github_url };
            scene.add(repoGroup);
            state.repoGroups.set(repoName, repoGroup);

            // Calculate summary color from child worktree statuses
            const childScores = collectStatusScores(tree.children);
            let repoColor, repoEmissiveIntensity, avgScore = 0.5;
            if (childScores.length === 0) {
                // No children, use default indigo (or gray in colorblind mode)
                repoColor = state.colorblind ? 0x888888 : 0x6366f1;
                repoEmissiveIntensity = 0.2;
            } else {
                // Average of all child scores
                avgScore = childScores.reduce((a, b) => a + b, 0) / childScores.length;
                repoColor = state.colorblind ? getColorblindGray(avgScore) : statusScoreToColor(avgScore);
                repoEmissiveIntensity = Math.max(0.1, 0.3 - avgScore * 0.2);
            }

            // Create repo center ball (represents default branch)
            const repoGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const repoMaterial = new THREE.MeshStandardMaterial({
                color: repoColor,
                emissive: repoColor,
                emissiveIntensity: state.colorblind ? 0.3 : 0.5,  // Less emissive for grayscale
                metalness: 0.1,
                roughness: 0.8,
            });
            const repoBall = new THREE.Mesh(repoGeometry, repoMaterial);
            repoBall.position.set(repoX, 0, repoZ);
            repoBall.userData = {
                type: 'repo',
                name: repoName,
                branch: tree.branch || 'main',
                github_url: tree.github_url
            };
            repoGroup.add(repoBall);

            // In colorblind mode, add emoji indicator for repo freshness
            if (state.colorblind && childScores.length > 0) {
                const freshnessEmoji = getFreshnessEmoji(avgScore);
                const emojiSprite = createEmojiSprite(freshnessEmoji);
                emojiSprite.position.set(repoX - 0.6, 0.6, repoZ);  // Top-left of repo ball
                emojiSprite.scale.set(0.5, 0.5, 1);
                emojiSprite.userData.isEmojiIndicator = true;
                repoGroup.add(emojiSprite);
            }

            // Create repo label (floating text sprite)
            const repoLabel = createTextSprite(repoName, {
                fontsize: 28,
                backgroundColor: 'rgba(0,0,0,0.8)',
                textColor: '#ffffff',
                padding: 30
            });
            repoLabel.position.set(repoX, 3, repoZ);
            // Scale based on actual text width
            const repoLabelWidth = (repoLabel.userData.canvasWidth || 256) / 80;
            repoLabel.scale.set(repoLabelWidth, 0.8, 1);
            repoGroup.add(repoLabel);

            // Build workspace nodes for this repo
            if (tree.children) {
                buildWorkspaceNodes(tree.children, repoGroup, repoX, repoZ, 0, angle, 0, tree.github_url);
            }
        });
    }

    function buildWorkspaceNodes(nodes, group, parentX, parentZ, depth, baseAngle, childIndex, githubUrl) {
        nodes.forEach((node, index) => {
            if (!node.workspace_id) {
                // Node without worktree - still recurse for children
                if (node.children && node.children.length > 0) {
                    buildWorkspaceNodes(node.children, group, parentX, parentZ, depth, baseAngle, index, githubUrl);
                }
                return;
            }

            if (state.hiddenWorkspaces.has(node.workspace_id)) return;

            // Calculate position with more spread
            const spreadFactor = 0.6; // Increased spread between sibling nodes
            const angleOffset = (index - (nodes.length - 1) / 2) * spreadFactor;
            const nodeAngle = baseAngle + angleOffset;
            const distance = 3 + depth * 2; // Increased distance from center

            const x = parentX + Math.cos(nodeAngle) * distance;
            const z = parentZ + Math.sin(nodeAngle) * distance;
            const y = depth * 0.3; // Slight vertical offset per depth level (going up)

            // Create workspace node
            const mesh = createWorkspaceNode(node, githubUrl);
            mesh.position.set(x, y, z);
            group.add(mesh);
            state.nodes.set(node.workspace_id, mesh);

            // Parent position
            const parentY = depth > 0 ? (depth - 1) * 0.3 : 0;

            // Create connection line with commits
            const commits = node.commits_from_parent || [];
            const themeColors = getThemeColors();
            const lineColor = commits.length > 0 ? themeColors.lineColor : (isDarkMode ? 0x444466 : 0xaaaacc);

            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(parentX, parentY, parentZ),
                new THREE.Vector3(x, y, z)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: lineColor,
                transparent: true,
                opacity: 0.7
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            group.add(line);
            state.lines.push(line);

            // Add commit points along the line
            if (commits.length > 0) {
                const commitGroup = createCommitPoints(
                    parentX, parentY, parentZ,
                    x, y, z,
                    commits,
                    githubUrl
                );
                group.add(commitGroup);
            }

            // Recurse for children
            if (node.children && node.children.length > 0) {
                buildWorkspaceNodes(node.children, group, x, z, depth + 1, nodeAngle, index, githubUrl);
            }
        });
    }

    function createCommitPoints(x1, y1, z1, x2, y2, z2, commits, githubUrl) {
        const commitGroup = new THREE.Group();
        const numCommits = Math.min(commits.length, 10); // Limit displayed commits

        for (let i = 0; i < numCommits; i++) {
            const commit = commits[i];
            // Position commits centered along the line with equal spacing from ends
            // 1 commit: 0.5 (middle), 2 commits: 0.33/0.67, 3 commits: 0.25/0.5/0.75, etc.
            const t = (i + 1) / (numCommits + 1);

            const cx = x1 + (x2 - x1) * t;
            const cy = y1 + (y2 - y1) * t;
            const cz = z1 + (z2 - z1) * t;

            // Create commit sphere
            const commitGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const commitColor = getThemeColors().commitColor;
            const commitMaterial = new THREE.MeshBasicMaterial({
                color: commitColor,
            });
            const commitMesh = new THREE.Mesh(commitGeometry, commitMaterial);
            commitMesh.position.set(cx, cy, cz);
            commitMesh.userData = {
                type: 'commit',
                commit: commit,
                github_url: commit.github_url
            };
            commitGroup.add(commitMesh);

            // Store in state for raycasting
            if (!state.commitNodes) state.commitNodes = [];
            state.commitNodes.push(commitMesh);
        }

        // Add commit count label if there are more commits than displayed
        if (commits.length > numCommits) {
            const midT = 0.5;
            const labelX = x1 + (x2 - x1) * midT;
            const labelY = y1 + (y2 - y1) * midT + 0.3;
            const labelZ = z1 + (z2 - z1) * midT;

            const countLabel = createTextSprite(`+${commits.length - numCommits} more`, {
                fontsize: 12,
                backgroundColor: 'rgba(100, 100, 200, 0.7)',
                textColor: '#ffffff',
                padding: 8
            });
            countLabel.position.set(labelX, labelY, labelZ);
            countLabel.scale.set(0.6, 0.3, 1);
            commitGroup.add(countLabel);
        }

        return commitGroup;
    }

    // Get status score for a node (used for coloring)
    // Returns 0-1 where 0 = fresh/green, 1 = stale/red
    function getNodeStatusScore(node) {
        const click = node.click_record;
        if (!click || !click.last_seen) {
            return 1; // No data = stale
        }
        const minutesAgo = (Date.now() - new Date(click.last_seen).getTime()) / 60000;
        // Clamp to 0-1 range based on staleMinutes
        return Math.min(1, minutesAgo / CONFIG.staleMinutes);
    }

    // Convert status score (0-1) to color (green -> yellow -> orange -> red)
    function statusScoreToColor(score) {
        // Green (0x22c55e) -> Yellow (0xeab308) -> Orange (0xf97316) -> Red (0xef4444)
        if (score < 0.33) {
            // Green to yellow
            const t = score / 0.33;
            return lerpColor(CONFIG.colors.fresh, CONFIG.colors.recent, t);
        } else if (score < 0.66) {
            // Yellow to orange
            const t = (score - 0.33) / 0.33;
            return lerpColor(CONFIG.colors.recent, CONFIG.colors.aging, t);
        } else {
            // Orange to red
            const t = (score - 0.66) / 0.34;
            return lerpColor(CONFIG.colors.aging, CONFIG.colors.stale, t);
        }
    }

    // Linear interpolation between two colors
    function lerpColor(color1, color2, t) {
        const r1 = (color1 >> 16) & 0xff;
        const g1 = (color1 >> 8) & 0xff;
        const b1 = color1 & 0xff;
        const r2 = (color2 >> 16) & 0xff;
        const g2 = (color2 >> 8) & 0xff;
        const b2 = color2 & 0xff;
        const r = Math.round(r1 + (r2 - r1) * t);
        const g = Math.round(g1 + (g2 - g1) * t);
        const b = Math.round(b1 + (b2 - b1) * t);
        return (r << 16) | (g << 8) | b;
    }

    // Collect all status scores from a tree of nodes
    function collectStatusScores(nodes, scores = []) {
        if (!nodes) return scores;
        for (const node of nodes) {
            if (node.workspace_id && !state.hiddenWorkspaces.has(node.workspace_id)) {
                scores.push(getNodeStatusScore(node));
            }
            if (node.children) {
                collectStatusScores(node.children, scores);
            }
        }
        return scores;
    }

    function createAwaitingIcon() {
        // Create a small sprite with an hourglass/waiting icon
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        // Draw circular background
        ctx.fillStyle = 'rgba(100, 100, 120, 0.9)';
        ctx.beginPath();
        ctx.arc(32, 32, 28, 0, Math.PI * 2);
        ctx.fill();

        // Draw hourglass icon
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('‚è≥', 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });

        const sprite = new THREE.Sprite(material);
        sprite.scale.set(0.25, 0.25, 1);  // Small icon size

        return sprite;
    }

    // Create emoji sprite for colorblind mode freshness indicators
    function createEmojiSprite(emoji) {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');

        // Draw emoji
        ctx.font = '48px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, 32, 32);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,
            depthWrite: false
        });

        const sprite = new THREE.Sprite(material);
        return sprite;
    }

    function createWorkspaceNode(node, githubUrl) {
        const click = node.click_record;
        const status = node.session_status;

        // Calculate status score and color (green to red based on freshness)
        const statusScore = getNodeStatusScore(node);
        // In colorblind mode, use grayscale; otherwise use color gradient
        const color = state.colorblind ? getColorblindGray(statusScore) : statusScoreToColor(statusScore);
        const emissiveIntensity = Math.max(0, 0.3 - statusScore * 0.3);

        // Store minutesAgo for time bar
        let minutesAgo = 0;
        if (click && click.last_seen) {
            minutesAgo = (Date.now() - new Date(click.last_seen).getTime()) / 60000;
        }

        // Create main sphere with vibrant color (or grayscale in colorblind mode)
        const geometry = new THREE.SphereGeometry(0.3, 32, 32);
        const material = new THREE.MeshStandardMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: state.colorblind ? 0.3 : 0.5,  // Less emissive for grayscale
            metalness: 0.1,
            roughness: 0.8,
        });

        const mesh = new THREE.Mesh(geometry, material);
        // Store github_url in node data for click handling
        node.github_url = githubUrl || node.github_url;
        mesh.userData = {
            type: 'workspace',
            data: node,
            statusScore: statusScore
        };

        // Add model indicator for working sessions (no ring, just the label)
        if (status && status.status === 'working' && status.model) {
            const modelLabel = createTextSprite(status.model, {
                fontsize: 10,
                backgroundColor: 'rgba(34, 197, 94, 0.8)',
                textColor: '#ffffff',
                padding: 6
            });
            modelLabel.position.set(0.5, 0.2, 0);
            modelLabel.scale.set(0.5, 0.25, 1);
            mesh.add(modelLabel);
        } else if (!status || status.status !== 'working') {
            // Add awaiting icon for non-working sessions
            const awaitingIcon = createAwaitingIcon();
            awaitingIcon.position.set(0, 0, 0.35);  // Positioned in front of the ball
            awaitingIcon.userData.isAwaitingIcon = true;
            mesh.add(awaitingIcon);
        }

        // In colorblind mode, add emoji indicator for freshness
        if (state.colorblind) {
            const freshnessEmoji = getFreshnessEmoji(statusScore);
            const emojiSprite = createEmojiSprite(freshnessEmoji);
            emojiSprite.position.set(-0.4, 0.4, 0);  // Top-left of ball
            emojiSprite.scale.set(0.35, 0.35, 1);
            emojiSprite.userData.isEmojiIndicator = true;
            emojiSprite.userData.orbitRadius = 0.5;
            mesh.add(emojiSprite);
        }

        // CI status will be shown in the PR label above the ball

        // Calculate time text for display in PR label area
        let timeText;
        if (minutesAgo === 0) {
            timeText = 'never';
        } else if (minutesAgo < 1) {
            timeText = 'now';
        } else if (minutesAgo < 60) {
            timeText = `${Math.floor(minutesAgo)}m`;
        } else if (minutesAgo < 1440) {
            timeText = `${Math.floor(minutesAgo / 60)}h`;
        } else {
            timeText = `${Math.floor(minutesAgo / 1440)}d`;
        }
        // Store for use in PR label
        mesh.userData.timeText = timeText;
        mesh.userData.timeColor = statusScore < 0.5 ? '#88ff88' : (statusScore < 0.75 ? '#ffcc44' : '#ff6666');

        // Add name label - show full PR title, positioned to orbit around ball
        const displayName = node.pr_title || node.name;
        const label = createTextSprite(displayName, {
            fontsize: 22,
            backgroundColor: 'rgba(0,0,0,0.85)',
            textColor: '#ffffff',
            padding: 16,
            maxWidth: 300  // Force wrapping for long titles
        });
        // Calculate height based on number of lines
        const numLines = label.userData.numLines || 1;
        const labelHeight = 0.5 + (numLines - 1) * 0.25;
        label.position.set(0, -0.2, 0);  // Initial position, will be updated by orbit
        const labelWidth = (label.userData.canvasWidth || 256) / 90;
        label.scale.set(labelWidth, labelHeight, 1);
        // Mark as orbiting label with distance from center
        label.userData.isOrbitLabel = true;
        label.userData.orbitRadius = 1.2 + labelHeight / 2;  // Distance from ball center
        label.userData.orbitType = 'name';  // Name label orbits opposite to camera
        mesh.add(label);

        // Add status label above the ball - combines PR number, CI status, and time
        if (node.pr_number) {
            // Determine CI indicator symbol and color
            let ciSymbol = '';
            let bgColor = 'rgba(100, 100, 140, 0.9)';  // Default gray for unknown
            if (node.ci_status === 'pass') {
                ciSymbol = ' ‚úì';
                bgColor = 'rgba(34, 197, 94, 0.9)';  // Green
            } else if (node.ci_status === 'fail') {
                ciSymbol = ' ‚úó';
                bgColor = 'rgba(239, 68, 68, 0.9)';  // Red
            } else if (node.ci_status === 'pending') {
                ciSymbol = ' ‚ãØ';
                bgColor = 'rgba(234, 179, 8, 0.9)';  // Yellow
            } else {
                // Unknown/not fetched yet - show loading indicator
                ciSymbol = ' ‚óå';
            }

            // Combine PR number, CI status, and time into one label
            const statusLabel = createTextSprite(`#${node.pr_number}${ciSymbol} ¬∑ ${timeText}`, {
                fontsize: 18,
                backgroundColor: bgColor,
                textColor: '#ffffff',
                padding: 14,
                minCanvasWidth: 80
            });
            statusLabel.position.set(0, 0.2, 0);  // Initial position, will be updated by orbit
            statusLabel.scale.set(1.0, 0.4, 1);
            // Mark as orbiting label
            statusLabel.userData.isOrbitLabel = true;
            statusLabel.userData.orbitRadius = 0.8;  // Closer to ball than name label
            statusLabel.userData.orbitType = 'status';  // Status label on same side as name
            mesh.add(statusLabel);
        } else {
            // No PR - just show time indicator, orbiting around ball
            const timeLabel = createTextSprite(timeText, {
                fontsize: 14,
                backgroundColor: 'rgba(0,0,0,0.7)',
                textColor: mesh.userData.timeColor,
                padding: 10,
                minCanvasWidth: 48
            });
            timeLabel.position.set(0, 0.2, 0);  // Initial position, will be updated by orbit
            timeLabel.scale.set(0.5, 0.35, 1);
            // Mark as orbiting label
            timeLabel.userData.isOrbitLabel = true;
            timeLabel.userData.orbitRadius = 0.8;
            timeLabel.userData.orbitType = 'status';
            mesh.add(timeLabel);
        }

        return mesh;
    }

    function createTextSprite(text, options = {}) {
        const fontsize = options.fontsize || 18;
        const backgroundColor = options.backgroundColor || 'rgba(0,0,0,0.5)';
        const textColor = options.textColor || '#ffffff';
        const padding = options.padding || 20;
        const maxWidth = options.maxWidth || 400;  // Max width before wrapping
        const minCanvasWidth = options.minCanvasWidth || 256;  // Minimum canvas width

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');

        // Set font for measuring
        context.font = `${fontsize}px -apple-system, BlinkMacSystemFont, sans-serif`;

        // Word wrap text if needed
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';

        for (const word of words) {
            const testLine = currentLine ? currentLine + ' ' + word : word;
            const testWidth = context.measureText(testLine).width;
            if (testWidth > maxWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
            } else {
                currentLine = testLine;
            }
        }
        if (currentLine) lines.push(currentLine);

        // Calculate dimensions
        const lineHeight = fontsize * 1.3;
        let maxLineWidth = 0;
        for (const line of lines) {
            const lineWidth = context.measureText(line).width;
            if (lineWidth > maxLineWidth) maxLineWidth = lineWidth;
        }

        // Set canvas size based on text (use minCanvasWidth for flexibility)
        canvas.width = Math.max(minCanvasWidth, maxLineWidth + padding * 2);
        canvas.height = Math.max(64, lines.length * lineHeight + padding * 1.5);

        // Background with rounded corners
        context.fillStyle = backgroundColor;
        const radius = 8;
        context.beginPath();
        context.moveTo(radius, 0);
        context.lineTo(canvas.width - radius, 0);
        context.quadraticCurveTo(canvas.width, 0, canvas.width, radius);
        context.lineTo(canvas.width, canvas.height - radius);
        context.quadraticCurveTo(canvas.width, canvas.height, canvas.width - radius, canvas.height);
        context.lineTo(radius, canvas.height);
        context.quadraticCurveTo(0, canvas.height, 0, canvas.height - radius);
        context.lineTo(0, radius);
        context.quadraticCurveTo(0, 0, radius, 0);
        context.closePath();
        context.fill();

        // Draw text lines
        context.font = `${fontsize}px -apple-system, BlinkMacSystemFont, sans-serif`;
        context.fillStyle = textColor;
        context.textAlign = 'center';
        context.textBaseline = 'middle';

        const startY = (canvas.height - (lines.length - 1) * lineHeight) / 2;
        lines.forEach((line, i) => {
            context.fillText(line, canvas.width / 2, startY + i * lineHeight);
        });

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,  // Always render on top
            depthWrite: false
        });

        const sprite = new THREE.Sprite(material);
        // Scale based on canvas aspect ratio
        sprite.userData.canvasWidth = canvas.width;
        sprite.userData.canvasHeight = canvas.height;
        sprite.userData.numLines = lines.length;
        sprite.userData.isLabel = true;  // Mark as label for zoom scaling

        return sprite;
    }

    // ============================================================================
    // Animation & Rendering
    // ============================================================================
    function animate() {
        requestAnimationFrame(animate);

        spinnerRotation += 0.1;

        // Auto-fit camera to content if enabled
        if (state.autoFit) {
            fitToScreen();
        }

        // Calculate zoom scale factor - labels get bigger as camera zooms out
        // In fit mode, compensate for camera height to keep labels constant size
        let zoomScale;
        if (state.autoFit) {
            // Scale based on camera height to maintain constant apparent size
            // Reference height of 15 = scale 1.0, higher = larger labels to compensate
            const referenceHeight = 15;
            zoomScale = Math.max(0.5, Math.min(4, cameraHeight / referenceHeight));
        } else {
            // At cameraRadius 15 (default), scale = 1. At 30, scale = 1.5. At 5, scale = 0.7
            zoomScale = Math.max(0.5, Math.min(2, cameraRadius / 15));
        }

        // Update all label scales based on zoom
        function updateLabelScales(object) {
            object.traverse((child) => {
                if (child.isSprite && child.userData.isLabel) {
                    // Store base scale on first encounter
                    if (!child.userData.baseScale) {
                        child.userData.baseScale = {
                            x: child.scale.x,
                            y: child.scale.y,
                            z: child.scale.z
                        };
                    }
                    // Apply zoom scale to base scale
                    child.scale.set(
                        child.userData.baseScale.x * zoomScale,
                        child.userData.baseScale.y * zoomScale,
                        child.userData.baseScale.z
                    );
                }
            });
        }

        // Scale labels in repo groups
        state.repoGroups.forEach(group => updateLabelScales(group));

        // Update orbiting labels to position them away from camera view
        // Calculate how much the camera is looking from above (0 = side, 1 = directly above)
        const cameraElevation = Math.min(1, Math.max(0, (cameraHeight - 2) / 15));

        state.nodes.forEach((mesh) => {
            // Get mesh world position
            const meshWorldPos = new THREE.Vector3();
            mesh.getWorldPosition(meshWorldPos);

            // Calculate angle from mesh to camera in XZ plane
            const dx = camera.position.x - meshWorldPos.x;
            const dz = camera.position.z - meshWorldPos.z;
            const angleToCamera = Math.atan2(dx, dz);

            mesh.children.forEach((child) => {
                if (child.userData.isOrbitLabel) {
                    const baseRadius = child.userData.orbitRadius;

                    // When looking from above, position labels to the SIDE (perpendicular to camera)
                    // When looking from side, position above/below
                    let labelAngle;
                    if (child.userData.orbitType === 'name') {
                        // Name label: perpendicular to camera (90 degrees to the right)
                        labelAngle = angleToCamera + Math.PI / 2;
                    } else {
                        // Status label: perpendicular to camera (90 degrees to the left)
                        labelAngle = angleToCamera - Math.PI / 2;
                    }

                    // Spread distance - modest increase when looking from above
                    const spreadMultiplier = 1.0 + cameraElevation * 0.5;  // 1x to 1.5x spread
                    const radius = Math.min(baseRadius * spreadMultiplier, 2.0);  // Cap max radius

                    // Horizontal position (in XZ plane) - only spread horizontally when from above
                    const x = Math.sin(labelAngle) * radius * cameraElevation;
                    const z = Math.cos(labelAngle) * radius * cameraElevation;

                    // Vertical position: flatten when looking from above
                    // When side view (elevation=0): name below (-0.8), status above (0.5)
                    // When top view (elevation=1): both near ball level (0)
                    let y;
                    if (child.userData.orbitType === 'name') {
                        y = -0.8 * (1 - cameraElevation);  // Goes from -0.8 to 0
                    } else {
                        y = 0.5 * (1 - cameraElevation);   // Goes from 0.5 to 0
                    }

                    child.position.set(x, y, z);
                }
            });
        });

        // Animate working status rings
        state.nodes.forEach((mesh) => {
            mesh.children.forEach((child) => {
                if (child.userData.isStatusRing && child.userData.status === 'working') {
                    child.rotation.z = spinnerRotation;
                }
            });
        });

        // Animate flash effects for workspaces that just finished working
        const now = Date.now();
        state.flashingNodes.forEach((flashInfo, wsId) => {
            const elapsed = now - flashInfo.startTime;
            const progress = elapsed / flashInfo.duration;

            if (progress >= 1) {
                // Animation complete, remove from flashing set
                state.flashingNodes.delete(wsId);
                // Reset mesh to normal
                const mesh = state.nodes.get(wsId);
                if (mesh) {
                    mesh.scale.set(1, 1, 1);
                    if (mesh.material) {
                        mesh.material.emissiveIntensity = 0.5;
                    }
                }
            } else {
                // Animate the flash - pulse scale and emissive
                const mesh = state.nodes.get(wsId);
                if (mesh) {
                    // Create a pulsing effect: scale up then down
                    // Use sine wave for smooth pulse, 3 pulses over the duration
                    const pulsePhase = progress * Math.PI * 6;  // 3 full pulses
                    const pulseAmount = Math.sin(pulsePhase) * 0.3 * (1 - progress);  // Fade out
                    const scale = 1 + pulseAmount;
                    mesh.scale.set(scale, scale, scale);

                    // Flash the emissive white/bright
                    if (mesh.material) {
                        const flashIntensity = 0.5 + Math.abs(Math.sin(pulsePhase)) * 1.5 * (1 - progress);
                        mesh.material.emissiveIntensity = flashIntensity;
                        // Briefly flash to white during peaks
                        const whiteness = Math.max(0, Math.sin(pulsePhase)) * (1 - progress);
                        if (whiteness > 0.3) {
                            mesh.material.emissive.setHex(0xffffff);
                        } else {
                            mesh.material.emissive.setHex(mesh.material.color.getHex());
                        }
                    }
                }
            }
        });

        // Raycasting for hover - check commits first, then workspace nodes
        raycaster.setFromCamera(mouse, camera);

        // Check commit nodes first
        let foundHover = false;
        if (state.commitNodes && state.commitNodes.length > 0) {
            const commitIntersects = raycaster.intersectObjects(state.commitNodes, false);
            if (commitIntersects.length > 0) {
                const commitMesh = commitIntersects[0].object;
                if (commitMesh.userData.type === 'commit') {
                    if (state.hoveredNode !== commitMesh) {
                        state.hoveredNode = commitMesh;
                        showCommitTooltip(commitMesh.userData.commit);
                    }
                    foundHover = true;
                    // Highlight commit on hover
                    commitMesh.material.color.setHex(0xffcc00);
                    commitMesh.scale.set(1.5, 1.5, 1.5);
                }
            }
        }

        // Reset non-hovered commits
        if (state.commitNodes) {
            const commitColor = getThemeColors().commitColor;
            state.commitNodes.forEach(cm => {
                if (cm !== state.hoveredNode) {
                    cm.material.color.setHex(commitColor);
                    cm.scale.set(1, 1, 1);
                }
            });
        }

        // Check workspace nodes
        if (!foundHover) {
            const intersects = raycaster.intersectObjects(Array.from(state.nodes.values()), true);

            if (intersects.length > 0) {
                let targetMesh = intersects[0].object;
                // Walk up to find workspace mesh
                while (targetMesh && (!targetMesh.userData || targetMesh.userData.type !== 'workspace')) {
                    targetMesh = targetMesh.parent;
                }

                if (targetMesh && targetMesh.userData.type === 'workspace') {
                    if (state.hoveredNode !== targetMesh) {
                        state.hoveredNode = targetMesh;
                        showTooltip(targetMesh.userData.data);
                    }
                    foundHover = true;
                }
            }
        }

        if (!foundHover && state.hoveredNode) {
            state.hoveredNode = null;
            hideTooltip();
        }

        renderer.render(scene, camera);
    }

    // ============================================================================
    // UI Functions
    // ============================================================================
    function showTooltip(node) {
        const tooltip = document.getElementById('tooltip');
        const click = node.click_record;
        const status = node.session_status;

        tooltip.querySelector('.tooltip-title').textContent = node.name;
        tooltip.querySelector('.tooltip-repo').textContent = click ? click.repo_name : '';

        if (click && click.last_seen) {
            const minutesAgo = Math.floor((Date.now() - new Date(click.last_seen).getTime()) / 60000);
            tooltip.querySelector('.tooltip-time').textContent = formatTimeAgo(minutesAgo);
        } else {
            tooltip.querySelector('.tooltip-time').textContent = '';
        }

        if (status) {
            tooltip.querySelector('.tooltip-status').innerHTML = `
                <div class="status-icon status-${status.status}"></div>
                <span>${status.status}</span>
            `;
        } else {
            tooltip.querySelector('.tooltip-status').innerHTML = '';
        }

        tooltip.style.display = 'block';
    }

    function hideTooltip() {
        document.getElementById('tooltip').style.display = 'none';
    }

    function showCommitTooltip(commit) {
        const tooltip = document.getElementById('tooltip');

        tooltip.querySelector('.tooltip-title').textContent = commit.short_sha;
        tooltip.querySelector('.tooltip-repo').textContent = commit.message;
        tooltip.querySelector('.tooltip-time').textContent = `${commit.author} - ${commit.date}`;
        tooltip.querySelector('.tooltip-status').innerHTML = commit.github_url
            ? `<span style="color: #88aaff; cursor: pointer;">Click to open on GitHub</span>`
            : '';

        tooltip.style.display = 'block';
    }

    function formatTimeAgo(minutes) {
        if (minutes < 1) return 'just now';
        if (minutes < 60) return `${minutes}m ago`;
        return `${Math.floor(minutes / 60)}h ago`;
    }

    function truncate(str, len) {
        if (!str) return '';
        return str.length > len ? str.substring(0, len - 1) + '...' : str;
    }

    function updateStatusPanel() {
        if (!state.trackerData) return;

        const statuses = state.trackerData.session_statuses || {};
        let working = 0, idle = 0, error = 0;

        Object.values(statuses).forEach(s => {
            if (s.status === 'working') working++;
            else if (s.status === 'error') error++;
            else idle++;
        });

        document.getElementById('working-count').textContent = working;
        document.getElementById('idle-count').textContent = idle;
        document.getElementById('error-count').textContent = error;
    }

    function updateFooter() {
        const visibleCount = state.nodes.size;
        const hiddenWs = state.hiddenWorkspaces.size;
        const hiddenRepos = state.hiddenRepos.size;

        document.getElementById('worktree-count').textContent = visibleCount;

        let hiddenInfo = '';
        if (hiddenWs > 0 || hiddenRepos > 0) {
            const parts = [];
            if (hiddenWs > 0) parts.push(`${hiddenWs} ws`);
            if (hiddenRepos > 0) parts.push(`${hiddenRepos} repos`);
            hiddenInfo = `(${parts.join(', ')} hidden)`;
        }
        document.getElementById('hidden-info').textContent = hiddenInfo;

        const sessionMinutes = Math.floor((Date.now() - state.sessionStart) / 60000);
        if (sessionMinutes >= 60) {
            document.getElementById('session-duration').textContent =
                `${Math.floor(sessionMinutes / 60)}h ${sessionMinutes % 60}m`;
        } else {
            document.getElementById('session-duration').textContent = `${sessionMinutes}m`;
        }
    }

    // ============================================================================
    // Hide Menu
    // ============================================================================
    function openHideMenu() {
        state.hideMenuOpen = true;
        updateHideMenu();
        document.getElementById('hide-menu').style.display = 'block';
    }

    function closeHideMenu() {
        state.hideMenuOpen = false;
        document.getElementById('hide-menu').style.display = 'none';
    }

    function updateHideMenu() {
        if (!state.trackerData) return;

        const reposList = document.getElementById('repos-list');
        const workspacesList = document.getElementById('workspaces-list');

        // Build repos list
        const repos = Object.keys(state.trackerData.trees || {}).sort();
        reposList.innerHTML = repos.map((name, i) => {
            const key = String.fromCharCode(65 + i); // A, B, C...
            const isHidden = state.hiddenRepos.has(name);
            return `
                <div class="menu-item ${isHidden ? 'hidden' : ''}" data-type="repo" data-name="${name}">
                    <span class="key">${key}</span>
                    <span class="name">${name}</span>
                    <span class="status-badge ${isHidden ? 'hidden' : 'visible'}">${isHidden ? 'hidden' : 'visible'}</span>
                </div>
            `;
        }).join('');

        // Build workspaces list
        const workspaces = [];
        Object.values(state.trackerData.trees || {}).forEach(tree => {
            collectWorkspaces(tree, workspaces);
        });
        workspaces.sort((a, b) => a.name.localeCompare(b.name));

        workspacesList.innerHTML = workspaces.slice(0, 26).map((ws, i) => {
            const key = String.fromCharCode(97 + i); // a, b, c...
            const isHidden = state.hiddenWorkspaces.has(ws.workspace_id);
            return `
                <div class="menu-item ${isHidden ? 'hidden' : ''}" data-type="workspace" data-id="${ws.workspace_id}">
                    <span class="key">${key}</span>
                    <span class="name">${truncate(ws.name, 35)}</span>
                    <span class="status-badge ${isHidden ? 'hidden' : 'visible'}">${isHidden ? 'hidden' : 'visible'}</span>
                </div>
            `;
        }).join('');

        // Add click handlers
        reposList.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', () => {
                const name = item.dataset.name;
                if (state.hiddenRepos.has(name)) {
                    state.hiddenRepos.delete(name);
                } else {
                    state.hiddenRepos.add(name);
                }
                updateHideMenu();
                rebuildScene();
            });
        });

        workspacesList.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', () => {
                const id = item.dataset.id;
                if (state.hiddenWorkspaces.has(id)) {
                    state.hiddenWorkspaces.delete(id);
                } else {
                    state.hiddenWorkspaces.add(id);
                }
                updateHideMenu();
                rebuildScene();
            });
        });
    }

    function handleHideMenuKey(key) {
        if (!state.trackerData) return;

        const repos = Object.keys(state.trackerData.trees || {}).sort();
        const workspaces = [];
        Object.values(state.trackerData.trees || {}).forEach(tree => {
            collectWorkspaces(tree, workspaces);
        });
        workspaces.sort((a, b) => a.name.localeCompare(b.name));

        // Handle uppercase A-Z for repos
        if (key >= 'A' && key <= 'Z') {
            const index = key.charCodeAt(0) - 65;
            if (index < repos.length) {
                const name = repos[index];
                if (state.hiddenRepos.has(name)) {
                    state.hiddenRepos.delete(name);
                } else {
                    state.hiddenRepos.add(name);
                }
                updateHideMenu();
                rebuildScene();
            }
        }

        // Handle lowercase a-z for workspaces
        if (key >= 'a' && key <= 'z') {
            const index = key.charCodeAt(0) - 97;
            if (index < workspaces.length) {
                const ws = workspaces[index];
                if (state.hiddenWorkspaces.has(ws.workspace_id)) {
                    state.hiddenWorkspaces.delete(ws.workspace_id);
                } else {
                    state.hiddenWorkspaces.add(ws.workspace_id);
                }
                updateHideMenu();
                rebuildScene();
            }
        }
    }

    function collectWorkspaces(node, list) {
        if (node.workspace_id) {
            list.push(node);
        }
        if (node.children) {
            node.children.forEach(child => collectWorkspaces(child, list));
        }
    }

    function rebuildScene() {
        buildScene();
        updateFooter();
    }

    // ============================================================================
    // Status Transition Detection
    // ============================================================================
    function detectStatusTransitions(newData) {
        if (!newData || !newData.session_statuses) return;

        const newStatuses = newData.session_statuses;

        // Check each workspace for working -> non-working transition
        for (const [wsId, newStatus] of Object.entries(newStatuses)) {
            const prevStatus = state.previousStatuses.get(wsId);
            const wasWorking = prevStatus && prevStatus.status === 'working';
            const isNowNotWorking = newStatus.status !== 'working';

            if (wasWorking && isNowNotWorking) {
                // Trigger flash animation for this workspace
                state.flashingNodes.set(wsId, {
                    startTime: Date.now(),
                    duration: 1500,  // 1.5 second flash animation
                });
            }
        }

        // Update previous statuses for next comparison
        state.previousStatuses.clear();
        for (const [wsId, status] of Object.entries(newStatuses)) {
            state.previousStatuses.set(wsId, { ...status });
        }
    }

    // ============================================================================
    // Data Fetching
    // ============================================================================
    async function fetchData() {
        try {
            // Use AbortController for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout

            const response = await fetch(CONFIG.apiUrl, { signal: controller.signal });
            clearTimeout(timeoutId);

            if (!response.ok) throw new Error('API error');

            const data = await response.json();

            // Detect working -> non-working transitions before updating state
            detectStatusTransitions(data);

            state.trackerData = data;
            state.useDemo = false;

            document.getElementById('loading').style.display = 'none';
            document.querySelector('#header .subtitle').textContent = state.locked
                ? '3D Visualization (Locked)'
                : '3D Visualization';

            // Skip scene rebuild if locked
            if (!state.locked) {
                buildScene();
                updateStatusPanel();
                updateFooter();
            }

        } catch (error) {
            console.log('API not available, using demo data');
            // Show demo data for testing without backend
            if (!state.trackerData || state.useDemo) {
                state.trackerData = generateDemoData();
                state.useDemo = true;
                document.getElementById('loading').style.display = 'none';
                document.querySelector('#header .subtitle').textContent = state.locked
                    ? '3D Visualization (Demo Mode - Locked)'
                    : '3D Visualization (Demo Mode)';
                if (!state.locked) {
                    buildScene();
                    updateStatusPanel();
                    updateFooter();
                }
            }
        }
    }

    function generateDemoData() {
        // Demo data for testing without backend
        const demoCommits = [
            { sha: 'abc1234567890', short_sha: 'abc1234', message: 'Add dark mode toggle component', author: 'developer', date: '2024-12-01', github_url: 'https://github.com/example/conductor-cli/commit/abc1234567890' },
            { sha: 'def2345678901', short_sha: 'def2345', message: 'Implement theme context provider', author: 'developer', date: '2024-12-01', github_url: 'https://github.com/example/conductor-cli/commit/def2345678901' },
            { sha: 'ghi3456789012', short_sha: 'ghi3456', message: 'Add CSS variables for dark theme', author: 'developer', date: '2024-11-30', github_url: 'https://github.com/example/conductor-cli/commit/ghi3456789012' },
        ];

        const demoCommits2 = [
            { sha: 'jkl4567890123', short_sha: 'jkl4567', message: 'Fix memory leak in event listener', author: 'developer', date: '2024-12-02', github_url: 'https://github.com/example/conductor-cli/commit/jkl4567890123' },
            { sha: 'mno5678901234', short_sha: 'mno5678', message: 'Add cleanup on unmount', author: 'developer', date: '2024-12-02', github_url: 'https://github.com/example/conductor-cli/commit/mno5678901234' },
        ];

        const authCommits = [
            { sha: 'pqr6789012345', short_sha: 'pqr6789', message: 'Add user authentication routes', author: 'developer', date: '2024-11-28', github_url: 'https://github.com/example/my-app/commit/pqr6789012345' },
            { sha: 'stu7890123456', short_sha: 'stu7890', message: 'Implement JWT token validation', author: 'developer', date: '2024-11-28', github_url: 'https://github.com/example/my-app/commit/stu7890123456' },
            { sha: 'vwx8901234567', short_sha: 'vwx8901', message: 'Add password hashing', author: 'developer', date: '2024-11-27', github_url: 'https://github.com/example/my-app/commit/vwx8901234567' },
            { sha: 'yza9012345678', short_sha: 'yza9012', message: 'Create user model', author: 'developer', date: '2024-11-27', github_url: 'https://github.com/example/my-app/commit/yza9012345678' },
        ];

        const oauthCommits = [
            { sha: 'bcd0123456789', short_sha: 'bcd0123', message: 'Add OAuth provider config', author: 'developer', date: '2024-11-29', github_url: 'https://github.com/example/my-app/commit/bcd0123456789' },
            { sha: 'efg1234567890', short_sha: 'efg1234', message: 'Implement Google OAuth flow', author: 'developer', date: '2024-11-29', github_url: 'https://github.com/example/my-app/commit/efg1234567890' },
        ];

        return {
            trees: {
                'conductor-cli': {
                    name: 'conductor-cli',
                    branch: 'main',
                    github_url: 'https://github.com/example/conductor-cli',
                    children: [
                        {
                            name: 'Feature: Dark Mode',
                            branch: 'feature/dark-mode',
                            workspace_id: 'ws-1',
                            pr_number: 42,
                            ci_status: 'pass',
                            parent_branch_name: 'main',
                            commits_from_parent: demoCommits,
                            click_record: {
                                repo_name: 'conductor-cli',
                                last_seen: new Date(Date.now() - 5 * 60000).toISOString()
                            },
                            session_status: { status: 'working' },
                            children: []
                        },
                        {
                            name: 'Fix: Memory leak',
                            branch: 'fix/memory-leak',
                            workspace_id: 'ws-2',
                            pr_number: 38,
                            ci_status: 'pending',
                            parent_branch_name: 'main',
                            commits_from_parent: demoCommits2,
                            click_record: {
                                repo_name: 'conductor-cli',
                                last_seen: new Date(Date.now() - 20 * 60000).toISOString()
                            },
                            session_status: { status: 'idle' },
                            children: []
                        }
                    ]
                },
                'my-app': {
                    name: 'my-app',
                    branch: 'main',
                    github_url: 'https://github.com/example/my-app',
                    children: [
                        {
                            name: 'Add authentication',
                            branch: 'feature/auth',
                            workspace_id: 'ws-3',
                            pr_number: 15,
                            ci_status: 'fail',
                            parent_branch_name: 'main',
                            commits_from_parent: authCommits,
                            click_record: {
                                repo_name: 'my-app',
                                last_seen: new Date(Date.now() - 45 * 60000).toISOString()
                            },
                            session_status: { status: 'error' },
                            children: [
                                {
                                    name: 'OAuth integration',
                                    branch: 'feature/oauth',
                                    workspace_id: 'ws-4',
                                    pr_number: 16,
                                    ci_status: 'pending',
                                    parent_branch_name: 'feature/auth',
                                    commits_from_parent: oauthCommits,
                                    click_record: {
                                        repo_name: 'my-app',
                                        last_seen: new Date(Date.now() - 10 * 60000).toISOString()
                                    },
                                    session_status: { status: 'working' },
                                    children: []
                                }
                            ]
                        }
                    ]
                }
            },
            session_statuses: {
                'ws-1': { status: 'working' },
                'ws-2': { status: 'idle' },
                'ws-3': { status: 'error' },
                'ws-4': { status: 'working' }
            }
        };
    }

    // ============================================================================
    // Initialization
    // ============================================================================
    function init() {
        loadSavedTheme();
        loadSavedColorblind();
        initThree();
        fetchData();

        // Start polling
        setInterval(fetchData, CONFIG.pollInterval);

        // Start animation loop
        animate();
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    </script>
</body>
</html>
